{"version":3,"sources":["index.js","platform/index.js","platform/point-in-path.js","normalize-svg-path.js","a2c.js","parse-svg-path.js","abs-svg-path.js","is-svg-path.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AENA,AJYA,ACHA;AELA,AJYA,AGTA,AENA,AJYA,ACHA;AELA,AJYA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AOrBA,AJYA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AJYA,ACHA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,AENA,AHSA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AENA,ANkBA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AELA,AJYA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _toArray2 = require('babel-runtime/helpers/toArray');\n\nvar _toArray3 = _interopRequireDefault(_toArray2);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _symbol = require('babel-runtime/core-js/symbol');\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _spriteMath = require('sprite-math');\n\nvar _platform = require('./platform');\n\nvar _parseSvgPath = require('./parse-svg-path');\n\nvar _parseSvgPath2 = _interopRequireDefault(_parseSvgPath);\n\nvar _absSvgPath = require('./abs-svg-path');\n\nvar _absSvgPath2 = _interopRequireDefault(_absSvgPath);\n\nvar _normalizeSvgPath = require('./normalize-svg-path');\n\nvar _normalizeSvgPath2 = _interopRequireDefault(_normalizeSvgPath);\n\nvar _isSvgPath = require('./is-svg-path');\n\nvar _isSvgPath2 = _interopRequireDefault(_isSvgPath);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _initialPath = (0, _symbol2.default)('initialPath');\nvar _path = (0, _symbol2.default)('path');\nvar _bounds = (0, _symbol2.default)('bounds');\nvar _savedPaths = (0, _symbol2.default)('savedPaths');\nvar _renderProps = (0, _symbol2.default)('renderProps');\nvar _beginPath = (0, _symbol2.default)('beginPath');\n\nvar SvgPath = function () {\n  function SvgPath(d) {\n    (0, _classCallCheck3.default)(this, SvgPath);\n\n    if (!(0, _isSvgPath2.default)(d)) {\n      throw new Error('Not an SVG path!');\n    }\n\n    this[_initialPath] = (0, _absSvgPath2.default)((0, _parseSvgPath2.default)(d));\n    this[_path] = (0, _normalizeSvgPath2.default)(this[_initialPath]);\n    this[_bounds] = null;\n    this[_savedPaths] = [];\n    this[_renderProps] = {};\n    this[_beginPath] = false;\n  }\n\n  (0, _createClass3.default)(SvgPath, [{\n    key: 'save',\n    value: function save() {\n      this[_savedPaths].push({ path: this[_path],\n        bounds: this[_bounds],\n        renderProps: (0, _assign2.default)({}, this[_renderProps]) });\n      return this;\n    }\n  }, {\n    key: 'restore',\n    value: function restore() {\n      if (this[_savedPaths].length) {\n        var _savedPaths$pop = this[_savedPaths].pop(),\n            path = _savedPaths$pop.path,\n            bounds = _savedPaths$pop.bounds,\n            renderProps = _savedPaths$pop.renderProps;\n\n        this[_path] = path;\n        this[_bounds] = bounds;\n        this[_renderProps] = renderProps;\n      }\n      return this;\n    }\n  }, {\n    key: 'isPointInPath',\n    value: function isPointInPath(x, y) {\n      return (0, _platform.isPointInPath)(this, x, y);\n    }\n  }, {\n    key: 'isPointInStroke',\n    value: function isPointInStroke(x, y, _ref) {\n      var _ref$lineWidth = _ref.lineWidth,\n          lineWidth = _ref$lineWidth === undefined ? 1 : _ref$lineWidth,\n          _ref$lineCap = _ref.lineCap,\n          lineCap = _ref$lineCap === undefined ? 'butt' : _ref$lineCap,\n          _ref$lineJoin = _ref.lineJoin,\n          lineJoin = _ref$lineJoin === undefined ? 'miter' : _ref$lineJoin;\n\n      if (_platform.isPointInStroke) {\n        return (0, _platform.isPointInStroke)(this, x, y, { lineWidth: lineWidth, lineCap: lineCap, lineJoin: lineJoin });\n      }\n      // node-canvas return undefined\n    }\n  }, {\n    key: 'getPointAtLength',\n    value: function getPointAtLength(len) {\n      return (0, _platform.getPointAtLength)(this.d, len);\n    }\n  }, {\n    key: 'getTotalLength',\n    value: function getTotalLength() {\n      return (0, _platform.getTotalLength)(this.d);\n    }\n  }, {\n    key: 'transform',\n    value: function transform() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      this[_bounds] = null;\n      var m = new _spriteMath.Matrix(args);\n      var commands = this[_path];\n      this[_path] = commands.map(function (c) {\n        var _c = (0, _toArray3.default)(c),\n            cmd = _c[0],\n            args = _c.slice(1);\n\n        var transformed = [cmd];\n        for (var i = 0; i < args.length; i += 2) {\n          var x0 = args[i],\n              y0 = args[i + 1];\n\n          var _m$transformPoint = m.transformPoint(x0, y0),\n              _m$transformPoint2 = (0, _slicedToArray3.default)(_m$transformPoint, 2),\n              x = _m$transformPoint2[0],\n              y = _m$transformPoint2[1];\n\n          transformed.push(x, y);\n        }\n        return transformed;\n      });\n      return this;\n    }\n  }, {\n    key: 'translate',\n    value: function translate(x, y) {\n      var m = new _spriteMath.Matrix().translate(x, y);\n      return this.transform.apply(this, (0, _toConsumableArray3.default)(m.m));\n    }\n  }, {\n    key: 'rotate',\n    value: function rotate(deg) {\n      var m = new _spriteMath.Matrix().rotate(deg);\n      return this.transform.apply(this, (0, _toConsumableArray3.default)(m.m));\n    }\n  }, {\n    key: 'scale',\n    value: function scale(sx, sy) {\n      if (sy == null) sy = sx;\n      var m = new _spriteMath.Matrix().scale(sx, sy);\n      return this.transform.apply(this, (0, _toConsumableArray3.default)(m.m));\n    }\n  }, {\n    key: 'skew',\n    value: function skew(degX, degY) {\n      var m = new _spriteMath.Matrix().skew(degX, degY);\n      return this.transform.apply(this, (0, _toConsumableArray3.default)(m.m));\n    }\n  }, {\n    key: 'trim',\n    value: function trim() {\n      var _bounds2 = (0, _slicedToArray3.default)(this.bounds, 2),\n          x = _bounds2[0],\n          y = _bounds2[1];\n\n      this.translate(-x, -y);\n      return this;\n    }\n  }, {\n    key: 'beginPath',\n    value: function beginPath() {\n      this[_beginPath] = true;\n      return this;\n    }\n  }, {\n    key: 'to',\n    value: function to(context) {\n      var commands = this[_path];\n      var renderProps = this[_renderProps];\n      if (commands.length) {\n        if (this[_beginPath]) {\n          context.beginPath();\n        }\n        commands.forEach(function (c) {\n          var _c2 = (0, _toArray3.default)(c),\n              cmd = _c2[0],\n              args = _c2.slice(1);\n\n          if (cmd === 'M') {\n            context.moveTo.apply(context, (0, _toConsumableArray3.default)(args));\n          } else {\n            context.bezierCurveTo.apply(context, (0, _toConsumableArray3.default)(args));\n          }\n        });\n        if (this.isClosed) {\n          context.closePath();\n        }\n      }\n      (0, _assign2.default)(context, renderProps);\n      return {\n        stroke: function stroke() {\n          context.stroke();\n          return this;\n        },\n        fill: function fill() {\n          context.fill();\n          return this;\n        }\n      };\n    }\n  }, {\n    key: 'strokeStyle',\n    value: function strokeStyle(value) {\n      this[_renderProps].strokeStyle = value;\n      return this;\n    }\n  }, {\n    key: 'fillStyle',\n    value: function fillStyle(value) {\n      this[_renderProps].fillStyle = value;\n      return this;\n    }\n  }, {\n    key: 'lineWidth',\n    value: function lineWidth(value) {\n      this[_renderProps].lineWidth = value;\n      return this;\n    }\n  }, {\n    key: 'lineCap',\n    value: function lineCap(value) {\n      this[_renderProps].lineCap = value;\n      return this;\n    }\n  }, {\n    key: 'lineJoin',\n    value: function lineJoin(value) {\n      this[_renderProps].lineJoin = value;\n      return this;\n    }\n  }, {\n    key: 'bounds',\n    get: function get() {\n      if (!this[_bounds]) {\n        var path = this[_path];\n        this[_bounds] = [0, 0, 0, 0];\n        if (path.length) {\n          var bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n          for (var i = 0, l = path.length; i < l; i++) {\n            var points = path[i].slice(1);\n\n            for (var j = 0; j < points.length; j += 2) {\n              if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n              if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n              if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n              if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n            }\n          }\n          this[_bounds] = bounds;\n        }\n      }\n      return this[_bounds];\n    }\n  }, {\n    key: 'size',\n    get: function get() {\n      var bounds = this.bounds;\n      return [bounds[2] - bounds[0], bounds[3] - bounds[1]];\n    }\n  }, {\n    key: 'center',\n    get: function get() {\n      var _bounds3 = (0, _slicedToArray3.default)(this.bounds, 4),\n          x0 = _bounds3[0],\n          y0 = _bounds3[1],\n          x1 = _bounds3[2],\n          y1 = _bounds3[3];\n\n      return [(x0 + x1) / 2, (y0 + y1) / 2];\n    }\n  }, {\n    key: 'd',\n    get: function get() {\n      var path = this[_path].map(function (p) {\n        var _p = (0, _toArray3.default)(p),\n            c = _p[0],\n            points = _p.slice(1);\n\n        return c + points.join();\n      }).join('');\n      if (this.isClosed) {\n        path += 'Z';\n      }\n      return path;\n    }\n  }, {\n    key: 'path',\n    get: function get() {\n      return this[_path];\n    }\n  }, {\n    key: 'isClosed',\n    get: function get() {\n      var part = this[_initialPath][this[_initialPath].length - 1];\n      return part && part[0] === 'Z';\n    }\n  }]);\n  return SvgPath;\n}();\n\nexports.default = SvgPath;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPointInStroke = undefined;\n\nvar _map = require('babel-runtime/core-js/map');\n\nvar _map2 = _interopRequireDefault(_map);\n\nexports.getPointAtLength = getPointAtLength;\nexports.getTotalLength = getTotalLength;\nexports.isPointInPath = isPointInPath;\n\nvar _pointInPath = require('./point-in-path');\n\nvar _pointInPath2 = _interopRequireDefault(_pointInPath);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar getPoints = require('point-at-length');\n\nvar cacheMap = new _map2.default();\n\nfunction get(d) {\n  if (cacheMap.has(d)) {\n    return cacheMap.get(d);\n  }\n  var points = getPoints(d);\n  cacheMap.set(d, points);\n  return points;\n}\n\nfunction getPointAtLength(d, len) {\n  var points = get(d);\n  return points.at(len);\n}\n\nfunction getTotalLength(d) {\n  var points = get(d);\n  return points.length();\n}\n\nfunction isPointInPath(_ref, x, y) {\n  var path = _ref.path;\n\n  return (0, _pointInPath2.default)(path, x, y);\n}\n\nvar isPointInStroke = exports.isPointInStroke = null;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nexports.default = pointInPath;\n\nvar _normalizeSvgPath = require('../normalize-svg-path');\n\nvar _normalizeSvgPath2 = _interopRequireDefault(_normalizeSvgPath);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar clone = function clone(obj) {\n  if (typeof obj === 'function' || Object(obj) !== obj) {\n    return obj;\n  }\n\n  var res = new obj.constructor();\n  /* eslint-disable no-restricted-syntax */\n  for (var key in obj) {\n    /* eslint-disable no-prototype-builtins */\n    if (obj.hasOwnProperty(key)) {\n      res[key] = clone(obj[key]);\n    }\n    /* eslint-enable no-prototype-builtins */\n  }\n  /* eslint-enable no-restricted-syntax */\n  return res;\n}; // https://github.com/maxnachlinger/point-in-svg-path\n\n\nfunction paths(ps) {\n  var p = paths.ps = paths.ps || {};\n  if (p[ps]) {\n    p[ps].sleep = 100;\n  } else {\n    p[ps] = {\n      sleep: 100\n    };\n  }\n  setTimeout(function () {\n    /* eslint-disable no-restricted-syntax */\n    for (var key in p) {\n      /* eslint-disable no-prototype-builtins */\n      if (p.hasOwnProperty(key) && key !== ps) {\n        p[key].sleep--;\n        if (!p[key].sleep) delete p[key];\n      }\n      /* eslint-enable no-prototype-builtins */\n    }\n    /* eslint-enable no-restricted-syntax */\n  });\n  return p[ps];\n}\n\nfunction box(x, y, width, height) {\n  if (x == null) {\n    x = y = width = height = 0;\n  }\n  if (y == null) {\n    y = x.y;\n    width = x.width;\n    height = x.height;\n    x = x.x;\n  }\n  return {\n    x: x,\n    y: y,\n    width: width,\n    w: width,\n    height: height,\n    h: height,\n    x2: x + width,\n    y2: y + height,\n    cx: x + width / 2,\n    cy: y + height / 2,\n    r1: Math.min(width, height) / 2,\n    r2: Math.max(width, height) / 2,\n    r0: Math.sqrt(width * width + height * height) / 2,\n    path: rectPath(x, y, width, height),\n    vb: [x, y, width, height].join(' ')\n  };\n}\n\nfunction findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n  var t1 = 1 - t,\n      t13 = Math.pow(t1, 3),\n      t12 = Math.pow(t1, 2),\n      t2 = t * t,\n      t3 = t2 * t,\n      x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n      y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n      mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n      my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n      nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n      ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n      ax = t1 * p1x + t * c1x,\n      ay = t1 * p1y + t * c1y,\n      cx = t1 * c2x + t * p2x,\n      cy = t1 * c2y + t * p2y,\n      alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;\n  // (mx > nx || my < ny) && (alpha += 180);\n  return {\n    x: x,\n    y: y,\n    m: { x: mx, y: my },\n    n: { x: nx, y: ny },\n    start: { x: ax, y: ay },\n    end: { x: cx, y: cy },\n    alpha: alpha\n  };\n}\n\nfunction bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n  if (!Array.isArray(p1x)) {\n    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n  }\n  var bbox = curveDim.apply(undefined, (0, _toConsumableArray3.default)(p1x));\n  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);\n}\n\nfunction isPointInsideBBox(bbox, x, y) {\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\n\nfunction isBBoxIntersect(bbox1, bbox2) {\n  bbox1 = box(bbox1);\n  bbox2 = box(bbox2);\n  var _bbox = bbox1,\n      x1 = _bbox.x,\n      y1 = _bbox.y,\n      w1 = _bbox.width,\n      h1 = _bbox.height,\n      _bbox2 = bbox2,\n      x2 = _bbox2.x,\n      y2 = _bbox2.y,\n      w2 = _bbox2.width,\n      h2 = _bbox2.height;\n\n\n  var c1x = x1 + w1 / 2,\n      c1y = y1 + h1 / 2;\n\n  var c2x = x2 + w2 / 2,\n      c2y = y2 + h2 / 2;\n\n  return Math.abs(c1x - c2x) <= (w1 + w2) / 2 || Math.abs(c1y - c2y) <= (h1 + h2) / 2;\n}\n\nfunction base3(t, p1, p2, p3, p4) {\n  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n      t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n  return t * t2 - 3 * p1 + 3 * p2;\n}\n\nfunction bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n  if (z == null) {\n    z = 1;\n  }\n  z = Math.max(0, Math.min(z, 1));\n\n  var z2 = z / 2,\n      n = 12,\n      Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],\n      Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];\n  var sum = 0;\n  for (var i = 0; i < n; i++) {\n    var ct = z2 * Tvalues[i] + z2,\n        xbase = base3(ct, x1, x2, x3, x4),\n        ybase = base3(ct, y1, y2, y3, y4),\n        comb = xbase * xbase + ybase * ybase;\n    sum += Cvalues[i] * Math.sqrt(comb);\n  }\n  return z2 * sum;\n}\n\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {\n    return;\n  }\n  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n  if (!denominator) {\n    return;\n  }\n  var px = nx / denominator,\n      py = ny / denominator,\n      px2 = Number(px.toFixed(2)),\n      py2 = Number(py.toFixed(2));\n  if (px2 < Number(Math.min(x1, x2).toFixed(2)) || px2 > Number(Math.max(x1, x2).toFixed(2)) || px2 < Number(Math.min(x3, x4).toFixed(2)) || px2 > Number(Math.max(x3, x4).toFixed(2)) || py2 < Number(Math.min(y1, y2).toFixed(2)) || py2 > Number(Math.max(y1, y2).toFixed(2)) || py2 < Number(Math.min(y3, y4).toFixed(2)) || py2 > Number(Math.max(y3, y4).toFixed(2))) {\n    return;\n  }\n  return { x: px, y: py };\n}\n\nfunction interHelper(bez1, bez2, justCount) {\n  var bbox1 = bezierBBox(bez1),\n      bbox2 = bezierBBox(bez2);\n  if (!isBBoxIntersect(bbox1, bbox2)) {\n    return justCount ? 0 : [];\n  }\n  var l1 = bezlen.apply(0, bez1),\n      l2 = bezlen.apply(0, bez2),\n      n1 = Math.ceil(l1 / 8),\n      n2 = Math.ceil(l2 / 8),\n      dots1 = [],\n      dots2 = [],\n      xy = {};\n  var res = justCount ? 0 : [];\n  for (var i = 0; i < n1 + 1; i++) {\n    var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n    dots1.push({ x: p.x, y: p.y, t: i / n1 });\n  }\n  for (var _i = 0; _i < n2 + 1; _i++) {\n    var _p = findDotsAtSegment.apply(0, bez2.concat(_i / n2));\n    dots2.push({ x: _p.x, y: _p.y, t: _i / n2 });\n  }\n  for (var _i2 = 0; _i2 < n1; _i2++) {\n    for (var j = 0; j < n2; j++) {\n      var di = dots1[_i2],\n          di1 = dots1[_i2 + 1],\n          dj = dots2[j],\n          dj1 = dots2[j + 1],\n          ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x',\n          cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x',\n          is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n      if (is) {\n        if (xy[is.x.toFixed(4)] !== is.y.toFixed(4)) {\n          xy[is.x.toFixed(4)] = is.y.toFixed(4);\n          var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n              t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n          if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n            if (justCount) {\n              res++;\n            } else {\n              res.push({\n                x: is.x,\n                y: is.y,\n                t1: t1,\n                t2: t2\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\n\nfunction interPathHelper(path1, path2, justCount) {\n  var x1 = void 0,\n      y1 = void 0,\n      x2 = void 0,\n      y2 = void 0,\n      x1m = void 0,\n      y1m = void 0,\n      x2m = void 0,\n      y2m = void 0,\n      bez1 = void 0,\n      bez2 = void 0,\n      res = justCount ? 0 : [];\n  for (var i = 0, ii = path1.length; i < ii; i++) {\n    var pi = path1[i];\n    if (pi[0] === 'M') {\n      x1 = x1m = pi[1];\n      y1 = y1m = pi[2];\n    } else {\n      if (pi[0] === 'C') {\n        bez1 = [x1, y1].concat(pi.slice(1));\n        x1 = bez1[6];\n        y1 = bez1[7];\n      } else {\n        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n        x1 = x1m;\n        y1 = y1m;\n      }\n      for (var j = 0, jj = path2.length; j < jj; j++) {\n        var pj = path2[j];\n        if (pj[0] === 'M') {\n          x2 = x2m = pj[1];\n          y2 = y2m = pj[2];\n        } else {\n          if (pj[0] === 'C') {\n            bez2 = [x2, y2].concat(pj.slice(1));\n            x2 = bez2[6];\n            y2 = bez2[7];\n          } else {\n            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n            x2 = x2m;\n            y2 = y2m;\n          }\n          var intr = interHelper(bez1, bez2, justCount);\n          if (justCount) {\n            res += intr;\n          } else {\n            for (var k = 0, kk = intr.length; k < kk; k++) {\n              intr[k].segment1 = i;\n              intr[k].segment2 = j;\n              intr[k].bez1 = bez1;\n              intr[k].bez2 = bez2;\n            }\n            res = res.concat(intr);\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\n\nfunction pathBBox(path) {\n  var pth = paths(path);\n\n  if (pth.bbox) {\n    return clone(pth.bbox);\n  }\n\n  if (!path) {\n    return box();\n  }\n\n  var x = 0;\n  var y = 0;\n  var X = [];\n  var Y = [];\n  var p = [];\n\n  for (var i = 0, c = path.length; i < c; i++) {\n    p = path[i];\n    if (p[0] === 'M') {\n      x = p[1];\n      y = p[2];\n      X.push(x);\n      Y.push(y);\n    } else {\n      var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n      X = X.concat(dim.min.x, dim.max.x);\n      Y = Y.concat(dim.min.y, dim.max.y);\n      x = p[5];\n      y = p[6];\n    }\n  }\n\n  var xmin = Math.min.apply(0, X);\n  var ymin = Math.min.apply(0, Y);\n  var xmax = Math.max.apply(0, X);\n  var ymax = Math.max.apply(0, Y);\n  var bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n\n  pth.bbox = clone(bb);\n  return bb;\n}\n\nfunction rectPath(x, y, w, h, r) {\n  if (r) {\n    return [['M', Number(x) + Number(r), y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];\n  }\n  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];\n  // res.toString = toString;\n  return res;\n}\n\n// Returns bounding box of cubic bezier curve.\n// Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n// Original version: NISHIO Hirokazu\n// Modifications: https://github.com/timo22345\nfunction curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var tvalues = [],\n      bounds = [[], []];\n  var a = void 0,\n      b = void 0,\n      c = void 0,\n      t = void 0,\n      t1 = void 0,\n      t2 = void 0,\n      b2ac = void 0,\n      sqrtb2ac = void 0;\n  /* eslint-disable no-continue */\n  for (var i = 0; i < 2; ++i) {\n    if (i === 0) {\n      b = 6 * x0 - 12 * x1 + 6 * x2;\n      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n      c = 3 * x1 - 3 * x0;\n    } else {\n      b = 6 * y0 - 12 * y1 + 6 * y2;\n      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n      c = 3 * y1 - 3 * y0;\n    }\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) < 1e-12) {\n        continue;\n      }\n      t = -c / b;\n      if (t > 0 && t < 1) {\n        tvalues.push(t);\n      }\n      continue;\n    }\n    b2ac = b * b - 4 * c * a;\n    sqrtb2ac = Math.sqrt(b2ac);\n    if (b2ac < 0) {\n      continue;\n    }\n    t1 = (-b + sqrtb2ac) / (2 * a);\n    if (t1 > 0 && t1 < 1) {\n      tvalues.push(t1);\n    }\n    t2 = (-b - sqrtb2ac) / (2 * a);\n    if (t2 > 0 && t2 < 1) {\n      tvalues.push(t2);\n    }\n  }\n  /* eslint-enable no-continue */\n\n  var j = tvalues.length,\n      mt = void 0;\n  var jlen = j;\n\n  while (j--) {\n    t = tvalues[j];\n    mt = 1 - t;\n    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n  }\n\n  bounds[0][jlen] = x0;\n  bounds[1][jlen] = y0;\n  bounds[0][jlen + 1] = x3;\n  bounds[1][jlen + 1] = y3;\n  bounds[0].length = bounds[1].length = jlen + 2;\n\n  return {\n    min: { x: Math.min.apply(0, bounds[0]), y: Math.min.apply(0, bounds[1]) },\n    max: { x: Math.max.apply(0, bounds[0]), y: Math.max.apply(0, bounds[1]) }\n  };\n}\n\nfunction pointInPath(path, x, y) {\n  var bbox = pathBBox(path);\n\n  if (!isPointInsideBBox(bbox, x, y)) {\n    return false;\n  }\n\n  if (interPathHelper(path, (0, _normalizeSvgPath2.default)([['M', x, y], ['H', bbox.x2 + 10]]), 1) % 2 !== 1) {\n    return false;\n  }\n\n  return true;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nexports.default = normalize;\n\nvar _a2c = require('./a2c');\n\nvar _a2c2 = _interopRequireDefault(_a2c);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable */\nfunction normalize(path) {\n  // init state\n  var prev;\n  var result = [];\n  var bezierX = 0;\n  var bezierY = 0;\n  var startX = 0;\n  var startY = 0;\n  var quadX = null;\n  var quadY = null;\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    var seg = path[i];\n    var command = seg[0];\n\n    switch (command) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n      case 'A':\n        var curves = (0, _a2c2.default)(x, y, seg[6], seg[7], seg[4], seg[5], seg[1], seg[2], seg[3]);\n\n        if (!curves.length) continue;\n\n        curves = curves.map(function (curve) {\n          var _curve = (0, _slicedToArray3.default)(curve, 8),\n              x0 = _curve[0],\n              y0 = _curve[1],\n              x1 = _curve[2],\n              y1 = _curve[3],\n              x2 = _curve[4],\n              y2 = _curve[5],\n              x = _curve[6],\n              y = _curve[7];\n\n          return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n        });\n\n        for (var j = 0, c; j < curves.length; j++) {\n          c = curves[j];\n          seg = ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y];\n          if (j < curves.length - 1) result.push(seg);\n        }\n\n        break;\n      case 'S':\n        // default control point\n        var cx = x;\n        var cy = y;\n        if (prev == 'C' || prev == 'S') {\n          cx += cx - bezierX; // reflect the previous command's control\n          cy += cy - bezierY; // point relative to the current point\n        }\n        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        break;\n      case 'T':\n        if (prev == 'Q' || prev == 'T') {\n          quadX = x * 2 - quadX; // as with 'S' reflect previous control point\n          quadY = y * 2 - quadY;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);\n        break;\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);\n        break;\n      case 'L':\n        seg = line(x, y, seg[1], seg[2]);\n        break;\n      case 'H':\n        seg = line(x, y, seg[1], y);\n        break;\n      case 'V':\n        seg = line(x, y, x, seg[1]);\n        break;\n      case 'Z':\n        seg = line(x, y, startX, startY);\n        break;\n    }\n\n    // update state\n    prev = command;\n    x = seg[seg.length - 2];\n    y = seg[seg.length - 1];\n    if (seg.length > 4) {\n      bezierX = seg[seg.length - 4];\n      bezierY = seg[seg.length - 3];\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n    result.push(seg);\n  }\n\n  return result;\n} // https://github.com/jkroso/normalize-svg-path\n\n\nfunction line(x1, y1, x2, y2) {\n  return ['C', x1, y1, x2, y2, x2, y2];\n}\n\nfunction quadratic(x1, y1, cx, cy, x2, y2) {\n  return ['C', x1 / 3 + 2 / 3 * cx, y1 / 3 + 2 / 3 * cy, x2 / 3 + 2 / 3 * cx, y2 / 3 + 2 / 3 * cy, x2, y2];\n}\n/* eslint-enable */","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = a2c;\n// https://github.com/colinmeinke/svg-arc-to-cubic-bezier\n//\n// Convert an arc to a sequence of cubic bézier curves\n//\n\n\nvar TAU = Math.PI * 2;\n\n/* eslint-disable space-infix-ops */\n\n// Calculate an angle between two unit vectors\n//\n// Since we measure angle between radii of circular arcs,\n// we can use simplified math (without length normalization)\n//\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  var dot = ux * vx + uy * vy;\n\n  // Add this to work with arbitrary vectors:\n  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n  if (dot > 1.0) {\n    dot = 1.0;\n  }\n  if (dot < -1.0) {\n    dot = -1.0;\n  }\n\n  return sign * Math.acos(dot);\n}\n\n// Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, theta1, delta_theta]\n//\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;\n  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;\n\n  var rx_sq = rx * rx;\n  var ry_sq = ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p;\n\n  // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n  var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n\n  var cxp = radicant * rx / ry * y1p;\n  var cyp = radicant * -ry / rx * x1p;\n\n  // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n  var cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;\n  var cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2;\n\n  // Step 4.\n  //\n  // Compute angles (theta1, delta_theta).\n  //\n  var v1x = (x1p - cxp) / rx;\n  var v1y = (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n\n  var theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n  if (fs === 1 && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n\n  return [cx, cy, theta1, delta_theta];\n}\n\n//\n// Approximate one unit arc segment with bézier curves,\n// see http://math.stackexchange.com/questions/873224\n//\nfunction approximate_unit_arc(theta1, delta_theta) {\n  var alpha = 4 / 3 * Math.tan(delta_theta / 4);\n\n  var x1 = Math.cos(theta1);\n  var y1 = Math.sin(theta1);\n  var x2 = Math.cos(theta1 + delta_theta);\n  var y2 = Math.sin(theta1 + delta_theta);\n\n  return [x1, y1, x1 - y1 * alpha, y1 + x1 * alpha, x2 + y2 * alpha, y2 - x2 * alpha, x2, y2];\n}\n\nfunction a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {\n  var sin_phi = Math.sin(phi * TAU / 360);\n  var cos_phi = Math.cos(phi * TAU / 360);\n\n  // Make sure radii are valid\n  //\n  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;\n  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  }\n\n  // Compensate out-of-range radii\n  //\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  // Get center parameters (cx, cy, theta1, delta_theta)\n  //\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);\n\n  var result = [];\n  var theta1 = cc[2];\n  var delta_theta = cc[3];\n\n  // Split an arc to multiple segments, so each segment\n  // will be less than τ/4 (= 90°)\n  //\n  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  }\n\n  // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n  return result.map(function (curve) {\n    for (var _i = 0; _i < curve.length; _i += 2) {\n      var x = curve[_i + 0];\n      var y = curve[_i + 1];\n\n      // scale\n      x *= rx;\n      y *= ry;\n\n      // rotate\n      var xp = cos_phi * x - sin_phi * y;\n      var yp = sin_phi * x + cos_phi * y;\n\n      // translate\n      curve[_i + 0] = xp + cc[0];\n      curve[_i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = parse;\n// https://github.com/jkroso/parse-svg-path\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n/* eslint-disable */\nvar length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0\n\n\t/**\n  * segment pattern\n  * @type {RegExp}\n  */\n\n};var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = [];\n\tpath.replace(segment, function (_, command, args) {\n\t\tvar type = command.toLowerCase();\n\t\targs = parseValues(args);\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)));\n\t\t\ttype = 'l';\n\t\t\tcommand = command == 'm' ? 'l' : 'L';\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command);\n\t\t\t\treturn data.push(args);\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data');\n\t\t\tdata.push([command].concat(args.splice(0, length[type])));\n\t\t}\n\t});\n\treturn data;\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number);\n\treturn numbers ? numbers.map(Number) : [];\n}\n/* eslint-enable */","\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = absolutize;\n// https://github.com/jkroso/abs-svg-path\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\n/* eslint-disable */\nfunction absolutize(path) {\n\tvar startX = 0;\n\tvar startY = 0;\n\tvar x = 0;\n\tvar y = 0;\n\n\treturn path.map(function (seg) {\n\t\tseg = seg.slice();\n\t\tvar type = seg[0];\n\t\tvar command = type.toUpperCase();\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x;\n\t\t\t\t\tseg[7] += y;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x;\n\t\t\t\t\t\tseg[i++] += y;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX;\n\t\t\t\ty = startY;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1];\n\t\t\t\tbreak;\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1];\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1];\n\t\t\t\ty = startY = seg[2];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2];\n\t\t\t\ty = seg[seg.length - 1];\n\t\t}\n\n\t\treturn seg;\n\t});\n}\n/* eslint-enable */","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isPath;\n// https://github.com/dy/is-svg-path\n\nfunction isPath(str) {\n  if (typeof str !== 'string') return false;\n\n  str = str.trim();\n\n  // https://www.w3.org/TR/SVG/paths.html#PathDataBNF\n  if (/^[mzlhvcsqta]\\s*[-+.0-9][^mlhvzcsqta]+/i.test(str) && /[\\dz]$/i.test(str) && str.length > 4) return true;\n\n  return false;\n}"]}